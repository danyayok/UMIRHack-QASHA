# app/services/test_generator.py
import os
import asyncio
from pathlib import Path
from typing import Dict, List, Any
import logging

logger = logging.getLogger(__name__)


class TestGenerator:
    def __init__(self):
        self.template_cache = {}

    async def generate_tests(self, analysis_result: Dict[str, Any], repo_path: str) -> Dict[str, Any]:
        """Генерирует тесты на основе анализа кода"""
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, self._generate_tests_sync, analysis_result, repo_path)
        except Exception as e:
            logger.error(f"Test generation error: {e}")
            raise

    def _generate_tests_sync(self, analysis_result: Dict[str, Any], repo_path: str) -> Dict[str, Any]:
        """Синхронная генерация тестов"""
        generated_tests = {
            'total_generated': 0,
            'test_files': [],
            'coverage_estimate': 0,
            'frameworks_used': []
        }

        technologies = analysis_result.get('technologies', [])

        for tech in technologies:
            if tech == 'python':
                self._generate_python_tests(analysis_result, repo_path, generated_tests)
            elif tech == 'javascript':
                self._generate_javascript_tests(analysis_result, repo_path, generated_tests)

        return generated_tests

    def _generate_python_tests(self, analysis_result: Dict[str, Any], repo_path: str, generated_tests: Dict[str, Any]):
        """Генерирует Python тесты"""
        repo_path_obj = Path(repo_path)

        tests_dir = repo_path_obj / 'tests'
        tests_dir.mkdir(exist_ok=True)

        for file_path, file_info in analysis_result['file_structure'].items():
            if file_info['technology'] == 'python' and not file_info['is_test']:
                test_content = self._generate_python_test_file(file_path, repo_path)
                if test_content:
                    test_file_path = tests_dir / f"test_{Path(file_path).name}"
                    with open(test_file_path, 'w', encoding='utf-8') as f:
                        f.write(test_content)

                    generated_tests['test_files'].append(str(test_file_path.relative_to(repo_path)))
                    generated_tests['total_generated'] += 1

        init_file = tests_dir / '__init__.py'
        if not init_file.exists():
            init_file.write_text('# Generated by QA Autopilot\n')

        generated_tests['frameworks_used'].append('pytest')

    def _generate_python_test_file(self, source_file_path: str, repo_path: str) -> str:
        """Генерирует содержимое Python тестового файла"""
        template = '''"""
Auto-generated tests for {module_name}
Generated by QA Autopilot
"""

import pytest
import sys
import os

# Add source directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

try:
    from {import_path} import *
    HAS_MODULE = True
except ImportError as e:
    HAS_MODULE = False
    print(f"Warning: Could not import module: {{e}}")

@pytest.mark.skipif(not HAS_MODULE, reason="Module not available")
class Test{class_name}:
    """Test cases for {module_name}"""

    def test_module_import(self):
        """Test that module can be imported"""
        assert HAS_MODULE, "Module should be importable"

    def test_sample_functionality(self):
        """Sample test - replace with actual tests"""
        assert True

    def test_another_sample(self):
        """Another sample test"""
        assert 1 + 1 == 2

if __name__ == "__main__":
    pytest.main([__file__])
'''

        try:
            source_path = Path(source_file_path)
            module_name = source_path.stem
            class_name = module_name.title().replace('_', '')

            import_path = str(source_path.with_suffix('')).replace('/', '.').replace('\\', '.')

            return template.format(
                module_name=module_name,
                import_path=import_path,
                class_name=class_name
            )
        except Exception as e:
            logger.warning(f"Could not generate test for {source_file_path}: {e}")
            return None

    def _generate_javascript_tests(self, analysis_result: Dict[str, Any], repo_path: str,
                                   generated_tests: Dict[str, Any]):
        """Генерирует JavaScript тесты"""
        repo_path_obj = Path(repo_path)

        tests_dir = repo_path_obj / '__tests__'
        tests_dir.mkdir(exist_ok=True)

        template = '''/**
 * Auto-generated tests for {module_name}
 * Generated by QA Autopilot
 */

describe('{module_name}', () => {{
    test('module should be available', () => {{
        expect(true).toBe(true);
    }});

    test('sample functionality test', () => {{
        expect(1 + 1).toBe(2);
    }});
}});
'''

        test_file = tests_dir / 'autogenerated.test.js'
        with open(test_file, 'w', encoding='utf-8') as f:
            f.write(template.format(module_name='autogenerated'))

        generated_tests['test_files'].append(str(test_file.relative_to(repo_path)))
        generated_tests['total_generated'] += 1
        generated_tests['frameworks_used'].append('jest')